
1. As it mentioned in the textbook, the wait() function decrements a semaphore. If the result(decremented semaphore) is negative, then add the running process in the set of waiting processes.

The signal() function performs the opposite actions. First it increment a semaphore, then it check if there is any process is in the waitiong set of processes. If there is any, allow one of them continue.

We added these two into our two funcions, Producer() and Consumer(). Assume the producer goes first and consumer goes second. At first, consumed is initialized as 1. So, when the producer calls wait(consumed), it decreases to 0, and the process continue executing. Then, n++, print message, and signal(produced), and the produced becomes 1. At this time, there is no process waiting for "produced", so producer keeps running. In the next loop, it calls wait(consumed), it decreased to -1, so it become blocked and switched to producer. The producer calls wait(produced) and it becomes 0, then it print message and calls signal(consumed). Because the producer is waiting for this this signal, so it switches to the producer process.

Like the above, these two processes execute alternatively. Everytime the producer add 1 to n, it wait the consumer to consume it, and everytime the consumer consumed it, the consumer signals the producer and wake it up to continue. Gives us the result every n generated by producer consumed by consumer.

2.Yes. In the code file we tried just use one semphore as produced. As call wait in consumer and call signal in producer. The result is the same. The reason is just as the same as we mentioned in the first question. But this just for such simple application senario that there are no other things that interrupt the execution of these two processes. Otherwise, such synchronization can be disrupted.


3.Funtion.
consumer.c
#include <xinu.h>
#include <prodcons.h>

void consumer(int count) {
        int i;
        for (i = 0; i < count; i++) {
                wait(produced);
                printf("this is in consumer and n value is %d\n", n);
//              signal(consumed);
        }
}

producer.c
#include <xinu.h>
#include <prodcons.h>

void producer(int count) {
        int i;
        for (i = 0; i < count; i++) {
//              wait(consumed);
                n++;
                printf("this is in producer and n value is %d\n", n);
                signal(produced);
        }
}

xsh_prodcons.c
#include <xinu.h>
#include <prodcons.h>
#include<stdio.h>
#include<stdlib.h>
int n;                 //Definition for global variable 'n'
/*Now global variable n will be on Heap so it is accessible all the processes i.e. consume and produce*/

sid32 produced, consumed;
shellcmd xsh_prodcons(int nargs, char *args[])
{
        n = 0;
        int count;
        produced = semcreate(0);
        consumed = semcreate(1);
  //Argument verifications and validations
  if (nargs == 2) {
                count = atoi(args[1]);
        } else {
                count = 2000;
        }             //local varible to hold count

  //check args[1] if present assign value to count

  //create the process producer and consumer and put them in ready queue.
  //Look at the definations of function create and resume in the system folder for reference.      

  resume( create(consumer, 1024, 20, "consumer", 1, count));
  resume( create(producer, 1024, 20, "producer", 1, count));

  return (0);
}


In the assignment, our group discussed together and coded seperately.
